// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const analyticsUsers = `-- name: AnalyticsUsers :many
SELECT DISTINCT 
   COALESCE(REPLACE(r.user_id, '"', ''), 'N/A') as UserID,
   r.user_uuid,
   COALESCE(REPLACE(r.user_name, '"', ''), 'User') as UserName, 
   COALESCE(REPLACE(r.user_email, '"', ''), 'N/A') as UserEmail, 
   COALESCE(REPLACE(r.user_role, '"', ''), 'N/A') as UserRole, 
   r.locale,
   CAST(STRING_AGG(distinct r.ip_addr, ',') as text) as IPAddress,
   CAST(STRING_AGG(distinct r.user_agent, ',') as text) as UserAgent,
   CASE WHEN r.user_data IS NOT NULL THEN CAST(r.user_data as text) ELSE NULL END as UserData,
   COUNT(DISTINCT r.id) as ViewCount, 
   COUNT(DISTINCT ri.id) as ImpressionCount, 
   COUNT(DISTINCT rc.id) as CommentCount 
FROM post_reactions r 
  JOIN posts p on p.id = r.post_id 
  left join post_comments rc ON r.user_uuid = rc.user_uuid 
  left join post_reactions ri on r.user_uuid = ri.user_uuid and r.post_id = ri.post_id and ri.reaction is not null 
  WHERE p.project_id = $1 
    and ($2 = r.user_id or $2 = '' or $2 is null)
    and ($3::varchar = r.user_uuid::varchar or $3 = '' or $3 is null)
    and r.reaction is null 
GROUP BY r.user_id, r.user_uuid, UserName, UserEmail, UserRole, r.locale, UserData
`

type AnalyticsUsersParams struct {
	ProjectID int32
	UserID    sql.NullString
	Column3   string
}

type AnalyticsUsersRow struct {
	Userid          interface{}
	UserUuid        uuid.UUID
	Username        interface{}
	Useremail       interface{}
	Userrole        interface{}
	Locale          string
	Ipaddress       string
	Useragent       string
	Userdata        interface{}
	Viewcount       int64
	Impressioncount int64
	Commentcount    int64
}

func (q *Queries) AnalyticsUsers(ctx context.Context, arg AnalyticsUsersParams) ([]AnalyticsUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, analyticsUsers, arg.ProjectID, arg.UserID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyticsUsersRow
	for rows.Next() {
		var i AnalyticsUsersRow
		if err := rows.Scan(
			&i.Userid,
			&i.UserUuid,
			&i.Username,
			&i.Useremail,
			&i.Userrole,
			&i.Locale,
			&i.Ipaddress,
			&i.Useragent,
			&i.Userdata,
			&i.Viewcount,
			&i.Impressioncount,
			&i.Commentcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dashboardQuery = `-- name: DashboardQuery :one
SELECT COUNT(p.id), COUNT(rv.id), COUNT(rc.id) 
  FROM posts p 
    left join post_reactions rv on p.id = rv.id and rv.reaction is null 
    left join post_reactions rc on p.id = rc.id and (rc.id is null or rc.reaction is not null) 
  WHERE p.project_id = $1
`

type DashboardQueryRow struct {
	Count   int64
	Count_2 int64
	Count_3 int64
}

func (q *Queries) DashboardQuery(ctx context.Context, projectID int32) (DashboardQueryRow, error) {
	row := q.db.QueryRowContext(ctx, dashboardQuery, projectID)
	var i DashboardQueryRow
	err := row.Scan(&i.Count, &i.Count_2, &i.Count_3)
	return i, err
}

const deleteBoard = `-- name: DeleteBoard :one
DELETE FROM roadmap_boards WHERE id = $1 and project_id = $2 RETURNING id
`

type DeleteBoardParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteBoard(ctx context.Context, arg DeleteBoardParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteBoard, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteLabel = `-- name: DeleteLabel :one
DELETE FROM labels WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeleteLabelParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteLabel(ctx context.Context, arg DeleteLabelParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteLabel, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deletePost = `-- name: DeletePost :one
DELETE FROM posts WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeletePostParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deletePost, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteStatus = `-- name: DeleteStatus :one
DELETE FROM roadmap_statuses WHERE id = $1 and project_id = $2 RETURNING id
`

type DeleteStatusParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteStatus(ctx context.Context, arg DeleteStatusParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteStatus, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getAuthorByUser = `-- name: GetAuthorByUser :many

SELECT a.id, a.first_name, a.last_name, a.picture_url, a.user_id, a.project_id, a.created_on, a.updated_on, 
   s.id, s.subscription_start_date, s.is_annual, s.tier, 
   CASE 
    WHEN s.is_annual = false 
      THEN (s.subscription_start_date + INTERVAL '1 month') >= CURRENT_TIMESTAMP
    WHEN s.is_annual = true 
      THEN (s.subscription_start_date + INTERVAL '1 year') >= CURRENT_TIMESTAMP 
    ELSE false END as is_active,
   CASE 
    WHEN s.is_annual = false 
      THEN s.subscription_start_date + INTERVAL '1 month'
    WHEN s.is_annual = true 
      THEN s.subscription_start_date + INTERVAL '1 year'
    ELSE NULL END as expires_on
FROM authors a
  LEFT JOIN subscriptions s on 
    (a.id = s.subscriber_id and 
     s.subscription_start_date <= current_timestamp and
     s.success = true and
     s.stopped = false 
    ) 
    or s.id is null
WHERE a.user_id = $1
ORDER BY s.subscription_start_date DESC
LIMIT 1
`

type GetAuthorByUserRow struct {
	ID                    int32
	FirstName             string
	LastName              string
	PictureUrl            sql.NullString
	UserID                uuid.UUID
	ProjectID             int32
	CreatedOn             time.Time
	UpdatedOn             sql.NullTime
	ID_2                  sql.NullInt32
	SubscriptionStartDate sql.NullTime
	IsAnnual              sql.NullBool
	Tier                  sql.NullInt32
	IsActive              bool
	ExpiresOn             interface{}
}

// AUTHOR --
func (q *Queries) GetAuthorByUser(ctx context.Context, userID uuid.UUID) ([]GetAuthorByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAuthorByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAuthorByUserRow
	for rows.Next() {
		var i GetAuthorByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.UserID,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.ID_2,
			&i.SubscriptionStartDate,
			&i.IsAnnual,
			&i.Tier,
			&i.IsActive,
			&i.ExpiresOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoard = `-- name: GetBoard :one
SELECT id, name, description, is_private FROM roadmap_boards WHERE id = $1 AND project_id = $2
`

type GetBoardParams struct {
	ID        int32
	ProjectID int32
}

type GetBoardRow struct {
	ID          int32
	Name        string
	Description string
	IsPrivate   bool
}

func (q *Queries) GetBoard(ctx context.Context, arg GetBoardParams) (GetBoardRow, error) {
	row := q.db.QueryRowContext(ctx, getBoard, arg.ID, arg.ProjectID)
	var i GetBoardRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
	)
	return i, err
}

const getBoards = `-- name: GetBoards :many

SELECT id, name, is_private FROM roadmap_boards WHERE project_id = $1 order by created_on
`

type GetBoardsRow struct {
	ID        int32
	Name      string
	IsPrivate bool
}

// ROADMAP --
func (q *Queries) GetBoards(ctx context.Context, projectID int32) ([]GetBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBoards, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBoardsRow
	for rows.Next() {
		var i GetBoardsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.IsPrivate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLabels = `-- name: GetLabels :many
SELECT id, label, color, project_id, created_on, updated_on from labels WHERE project_id = $1 ORDER BY created_on
`

// LABELS --
func (q *Queries) GetLabels(ctx context.Context, projectID int32) ([]Label, error) {
	rows, err := q.db.QueryContext(ctx, getLabels, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Label
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Color,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextSortOrderForStatus = `-- name: GetNextSortOrderForStatus :one
SELECT MAX(sort_order) + 1 as NextSortOrder FROM roadmap_statuses WHERE project_id = $1
`

func (q *Queries) GetNextSortOrderForStatus(ctx context.Context, projectID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextSortOrderForStatus, projectID)
	var nextsortorder int32
	err := row.Scan(&nextsortorder)
	return nextsortorder, err
}

const getPost = `-- name: GetPost :one
SELECT p.id, p.title, p.body, p.published_on, p.author_id, p.project_id, p.created_on, p.updated_on, p.label_id, p.is_published, p.expires_on, l.label as Label FROM posts p LEFT JOIN labels l on p.label_id = l.id or p.label_id is null WHERE p.id = $1 AND p.project_id = $2
`

type GetPostParams struct {
	ID        int32
	ProjectID int32
}

type GetPostRow struct {
	ID          int32
	Title       string
	Body        string
	PublishedOn time.Time
	AuthorID    int32
	ProjectID   int32
	CreatedOn   time.Time
	UpdatedOn   sql.NullTime
	LabelID     sql.NullInt32
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (GetPostRow, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.ID, arg.ProjectID)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
		&i.Label,
	)
	return i, err
}

const getPostComments = `-- name: GetPostComments :many
SELECT p.id, p.title, c.comment, c.created_on, r.locale, ur.reaction, REPLACE(r.user_name, '"', '') as UserName, REPLACE(r.user_role, '"', '') as UserRole
	FROM posts p 
		JOIN post_comments c ON c.post_id = p.id 
		JOIN post_reactions r ON r.user_uuid = c.user_uuid AND r.post_id = p.id AND r.reaction IS NULL 
		LEFT JOIN post_reactions ur ON ur.user_uuid = c.user_uuid AND ur.post_id = p.id AND ur.reaction IS NOT NULL 
WHERE p.project_id = $1
    and ($2 = r.user_id or $2 = '' or $2 is null)
    and ($3::varchar = r.user_uuid::varchar or $3 = '' or $3 is null)
    and (p.id = $4 OR $4 = 0)
ORDER BY c.created_on DESC
`

type GetPostCommentsParams struct {
	ProjectID int32
	UserID    sql.NullString
	Column3   string
	ID        int32
}

type GetPostCommentsRow struct {
	ID        int32
	Title     string
	Comment   string
	CreatedOn time.Time
	Locale    string
	Reaction  sql.NullString
	Username  string
	Userrole  string
}

func (q *Queries) GetPostComments(ctx context.Context, arg GetPostCommentsParams) ([]GetPostCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostComments,
		arg.ProjectID,
		arg.UserID,
		arg.Column3,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostCommentsRow
	for rows.Next() {
		var i GetPostCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Comment,
			&i.CreatedOn,
			&i.Locale,
			&i.Reaction,
			&i.Username,
			&i.Userrole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostCount = `-- name: GetPostCount :one
SELECT COUNT(id) total_posts FROM posts WHERE project_id = $1
`

// POSTS --
func (q *Queries) GetPostCount(ctx context.Context, projectID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostCount, projectID)
	var total_posts int64
	err := row.Scan(&total_posts)
	return total_posts, err
}

const getPostReactions = `-- name: GetPostReactions :many
SELECT 
  CASE WHEN r.reaction IS NULL THEN '' ELSE r.reaction END as Reaction, 
  COUNT(r.*) 
FROM posts p 
  JOIN post_reactions r ON r.post_id = p.id 
WHERE p.project_id = $1 
    and ($2 = r.user_id or $2 = '' or $2 is null)
    and ($3::varchar = r.user_uuid::varchar or $3 = '' or $3 is null)
    and (p.id = $4 OR $4 = 0)
GROUP BY r.reaction 
ORDER BY r.reaction NULLS FIRST
`

type GetPostReactionsParams struct {
	ProjectID int32
	UserID    sql.NullString
	Column3   string
	ID        int32
}

type GetPostReactionsRow struct {
	Reaction interface{}
	Count    int64
}

func (q *Queries) GetPostReactions(ctx context.Context, arg GetPostReactionsParams) ([]GetPostReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostReactions,
		arg.ProjectID,
		arg.UserID,
		arg.Column3,
		arg.ID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostReactionsRow
	for rows.Next() {
		var i GetPostReactionsRow
		if err := rows.Scan(&i.Reaction, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPosts = `-- name: GetPosts :many
SELECT p.id, p.title, p.published_on, p.is_published, p.expires_on, l.label, l.color, 
  CASE WHEN p.published_on <= current_timestamp THEN 
    CASE WHEN p.expires_on is not null and p.expires_on <= current_timestamp THEN 2 
       ELSE 1 END 
      ELSE 0 END AS status, 
  COUNT(r.id) as ViewCount FROM posts p 
       left join labels l on p.label_id = l.id 
       left join post_reactions r on (p.id = r.post_id and r.reaction is null) OR r.id is null 
  WHERE p.project_id = $1
  GROUP BY 1,2,3,4,5,6,7
  ORDER BY p.published_on DESC
`

type GetPostsRow struct {
	ID          int32
	Title       string
	PublishedOn time.Time
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
	Color       sql.NullString
	Status      int32
	Viewcount   int64
}

func (q *Queries) GetPosts(ctx context.Context, projectID int32) ([]GetPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPosts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsRow
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PublishedOn,
			&i.IsPublished,
			&i.ExpiresOn,
			&i.Label,
			&i.Color,
			&i.Status,
			&i.Viewcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsForBoard = `-- name: GetPostsForBoard :many
SELECT rp.id, title, body, due_date, board_id, rp.project_id, status_id, rp.created_on, is_private, author_id, rp.user_uuid, is_idea, a.id, first_name, last_name, picture_url, a.user_id, a.project_id, a.created_on, updated_on, u.id, u.user_uuid, ip_addr, user_agent, locale, reaction, post_id, u.created_on, user_data, u.user_id, user_name, user_email, user_role
from roadmap_posts rp 
  left join authors a on a.id = rp.author_id
  left join post_reactions u on u.user_uuid = rp.user_uuid
where rp.board_id = $1 and rp.project_id = $2
order by due_date
`

type GetPostsForBoardParams struct {
	BoardID   sql.NullInt32
	ProjectID int32
}

type GetPostsForBoardRow struct {
	ID          int32
	Title       string
	Body        string
	DueDate     sql.NullTime
	BoardID     sql.NullInt32
	ProjectID   int32
	StatusID    sql.NullInt32
	CreatedOn   time.Time
	IsPrivate   bool
	AuthorID    sql.NullInt32
	UserUuid    uuid.NullUUID
	IsIdea      bool
	ID_2        sql.NullInt32
	FirstName   sql.NullString
	LastName    sql.NullString
	PictureUrl  sql.NullString
	UserID      uuid.NullUUID
	ProjectID_2 sql.NullInt32
	CreatedOn_2 sql.NullTime
	UpdatedOn   sql.NullTime
	ID_3        sql.NullInt32
	UserUuid_2  uuid.NullUUID
	IpAddr      sql.NullString
	UserAgent   sql.NullString
	Locale      sql.NullString
	Reaction    sql.NullString
	PostID      sql.NullInt32
	CreatedOn_3 sql.NullTime
	UserData    pqtype.NullRawMessage
	UserID_2    sql.NullString
	UserName    sql.NullString
	UserEmail   sql.NullString
	UserRole    sql.NullString
}

func (q *Queries) GetPostsForBoard(ctx context.Context, arg GetPostsForBoardParams) ([]GetPostsForBoardRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsForBoard, arg.BoardID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsForBoardRow
	for rows.Next() {
		var i GetPostsForBoardRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.DueDate,
			&i.BoardID,
			&i.ProjectID,
			&i.StatusID,
			&i.CreatedOn,
			&i.IsPrivate,
			&i.AuthorID,
			&i.UserUuid,
			&i.IsIdea,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.UserID,
			&i.ProjectID_2,
			&i.CreatedOn_2,
			&i.UpdatedOn,
			&i.ID_3,
			&i.UserUuid_2,
			&i.IpAddr,
			&i.UserAgent,
			&i.Locale,
			&i.Reaction,
			&i.PostID,
			&i.CreatedOn_3,
			&i.UserData,
			&i.UserID_2,
			&i.UserName,
			&i.UserEmail,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :many
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects WHERE user_id = $1 LIMIT 1
`

// PROJECTS --
func (q *Queries) GetProject(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProject, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AccentColor,
			&i.LogoUrl,
			&i.AppKey,
			&i.UserID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByKey = `-- name: GetProjectByKey :one
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects where app_key = $1 LIMIT 1
`

func (q *Queries) GetProjectByKey(ctx context.Context, appKey string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByKey, appKey)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const getPublishedPagedPosts = `-- name: GetPublishedPagedPosts :many
SELECT post.id, post.title, post.body, post.published_on, post.author_id, post.project_id, post.created_on, post.updated_on, post.label_id, post.is_published, post.expires_on, l.label, l.color, a.first_name, a.last_name, a.picture_url, r.reaction, CASE WHEN v.id IS NULL THEN 0 ELSE 1 END as Viewed
  FROM posts post 
    join projects proj on post.project_id = proj.id 
	join authors a on a.id = post.author_id 
	left join labels l on post.label_id = l.id or post.label_id is null 
	left join post_reactions r on (r.post_id = post.id and r.user_uuid = $4 and r.reaction is not null) or r.id is null 
	left join post_reactions v on (v.post_id = post.id and v.user_uuid = $4 and v.reaction is null) or v.id is null 
WHERE proj.app_key = $1 
   AND post.published_on <= CURRENT_TIMESTAMP 
   AND (post.expires_on IS NULL OR post.expires_on >= CURRENT_TIMESTAMP)
   AND post.is_published = true
   AND ($5 = '' OR LOWER(post.title) LIKE $5)
ORDER BY post.published_on DESC 
LIMIT $2 
OFFSET $3
`

type GetPublishedPagedPostsParams struct {
	AppKey   string
	Limit    int32
	Offset   int32
	UserUuid uuid.UUID
	Column5  interface{}
}

type GetPublishedPagedPostsRow struct {
	ID          int32
	Title       string
	Body        string
	PublishedOn time.Time
	AuthorID    int32
	ProjectID   int32
	CreatedOn   time.Time
	UpdatedOn   sql.NullTime
	LabelID     sql.NullInt32
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
	Color       sql.NullString
	FirstName   string
	LastName    string
	PictureUrl  sql.NullString
	Reaction    sql.NullString
	Viewed      int32
}

func (q *Queries) GetPublishedPagedPosts(ctx context.Context, arg GetPublishedPagedPostsParams) ([]GetPublishedPagedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublishedPagedPosts,
		arg.AppKey,
		arg.Limit,
		arg.Offset,
		arg.UserUuid,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublishedPagedPostsRow
	for rows.Next() {
		var i GetPublishedPagedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.PublishedOn,
			&i.AuthorID,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.LabelID,
			&i.IsPublished,
			&i.ExpiresOn,
			&i.Label,
			&i.Color,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.Reaction,
			&i.Viewed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaction = `-- name: GetReaction :many
SELECT reaction FROM post_reactions WHERE user_uuid = $1 AND post_id = $2 AND reaction IS NOT NULL
`

type GetReactionParams struct {
	UserUuid uuid.UUID
	PostID   int32
}

func (q *Queries) GetReaction(ctx context.Context, arg GetReactionParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getReaction, arg.UserUuid, arg.PostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var reaction sql.NullString
		if err := rows.Scan(&reaction); err != nil {
			return nil, err
		}
		items = append(items, reaction)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoadmapPost = `-- name: GetRoadmapPost :one
SELECT id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, user_uuid, is_idea FROM roadmap_posts WHERE id = $1 AND project_id = $2
`

type GetRoadmapPostParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) GetRoadmapPost(ctx context.Context, arg GetRoadmapPostParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, getRoadmapPost, arg.ID, arg.ProjectID)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.UserUuid,
		&i.IsIdea,
	)
	return i, err
}

const getStatus = `-- name: GetStatus :one
SELECT id, status, description, sort_order, color FROM roadmap_statuses WHERE id = $1 AND project_id = $2
`

type GetStatusParams struct {
	ID        int32
	ProjectID int32
}

type GetStatusRow struct {
	ID          int32
	Status      string
	Description string
	SortOrder   int32
	Color       string
}

func (q *Queries) GetStatus(ctx context.Context, arg GetStatusParams) (GetStatusRow, error) {
	row := q.db.QueryRowContext(ctx, getStatus, arg.ID, arg.ProjectID)
	var i GetStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Description,
		&i.SortOrder,
		&i.Color,
	)
	return i, err
}

const getStatuses = `-- name: GetStatuses :many
SELECT id, status, sort_order, color FROM roadmap_statuses WHERE project_id = $1 ORDER BY sort_order
`

type GetStatusesRow struct {
	ID        int32
	Status    string
	SortOrder int32
	Color     string
}

func (q *Queries) GetStatuses(ctx context.Context, projectID int32) ([]GetStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatuses, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesRow
	for rows.Next() {
		var i GetStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.SortOrder,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPostsForBoard = `-- name: HasPostsForBoard :one
SELECT COUNT(*) FROM roadmap_posts WHERE board_id = $1
`

func (q *Queries) HasPostsForBoard(ctx context.Context, boardID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasPostsForBoard, boardID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const hasPostsForStatus = `-- name: HasPostsForStatus :one
SELECT COUNT(*) FROM roadmap_posts WHERE status_id = $1
`

func (q *Queries) HasPostsForStatus(ctx context.Context, statusID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasPostsForStatus, statusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertAuthor = `-- name: InsertAuthor :one
INSERT INTO authors (first_name, last_name, picture_url, user_id, project_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, first_name, last_name, picture_url, user_id, project_id, created_on, updated_on
`

type InsertAuthorParams struct {
	FirstName  string
	LastName   string
	PictureUrl sql.NullString
	UserID     uuid.UUID
	ProjectID  int32
}

func (q *Queries) InsertAuthor(ctx context.Context, arg InsertAuthorParams) (Author, error) {
	row := q.db.QueryRowContext(ctx, insertAuthor,
		arg.FirstName,
		arg.LastName,
		arg.PictureUrl,
		arg.UserID,
		arg.ProjectID,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PictureUrl,
		&i.UserID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertBoard = `-- name: InsertBoard :one
INSERT INTO roadmap_boards (name, is_private, description, project_id, created_on) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP) RETURNING id, name, is_private, description, created_on, project_id
`

type InsertBoardParams struct {
	Name        string
	IsPrivate   bool
	Description string
	ProjectID   int32
}

func (q *Queries) InsertBoard(ctx context.Context, arg InsertBoardParams) (RoadmapBoard, error) {
	row := q.db.QueryRowContext(ctx, insertBoard,
		arg.Name,
		arg.IsPrivate,
		arg.Description,
		arg.ProjectID,
	)
	var i RoadmapBoard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsPrivate,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
	)
	return i, err
}

const insertComment = `-- name: InsertComment :one
INSERT INTO post_comments (user_uuid, comment, post_id) VALUES ($1, $2, $3) RETURNING id, user_uuid, comment, post_id, created_on
`

type InsertCommentParams struct {
	UserUuid uuid.UUID
	Comment  string
	PostID   int32
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, insertComment, arg.UserUuid, arg.Comment, arg.PostID)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.Comment,
		&i.PostID,
		&i.CreatedOn,
	)
	return i, err
}

const insertLabel = `-- name: InsertLabel :one
INSERT INTO labels (label, color, project_id) VALUES ($1, $2, $3) RETURNING id, label, color, project_id, created_on, updated_on
`

type InsertLabelParams struct {
	Label     string
	Color     string
	ProjectID int32
}

func (q *Queries) InsertLabel(ctx context.Context, arg InsertLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, insertLabel, arg.Label, arg.Color, arg.ProjectID)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO posts (title, body, published_on, is_published, label_id, author_id, project_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id, is_published, expires_on
`

type InsertPostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	IsPublished sql.NullBool
	LabelID     sql.NullInt32
	AuthorID    int32
	ProjectID   int32
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, insertPost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.IsPublished,
		arg.LabelID,
		arg.AuthorID,
		arg.ProjectID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
	)
	return i, err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO projects (name, description, accent_color, logo_url, app_key, user_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type InsertProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	AppKey      string
	UserID      uuid.UUID
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, insertProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.AppKey,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertReaction = `-- name: InsertReaction :one
INSERT INTO post_reactions (user_uuid, ip_addr, user_agent, locale, reaction, user_id, user_name, user_email, user_role, user_data, post_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, user_uuid, ip_addr, user_agent, locale, reaction, post_id, created_on, user_data, user_id, user_name, user_email, user_role
`

type InsertReactionParams struct {
	UserUuid  uuid.UUID
	IpAddr    string
	UserAgent string
	Locale    string
	Reaction  sql.NullString
	UserID    sql.NullString
	UserName  sql.NullString
	UserEmail sql.NullString
	UserRole  sql.NullString
	UserData  pqtype.NullRawMessage
	PostID    int32
}

func (q *Queries) InsertReaction(ctx context.Context, arg InsertReactionParams) (PostReaction, error) {
	row := q.db.QueryRowContext(ctx, insertReaction,
		arg.UserUuid,
		arg.IpAddr,
		arg.UserAgent,
		arg.Locale,
		arg.Reaction,
		arg.UserID,
		arg.UserName,
		arg.UserEmail,
		arg.UserRole,
		arg.UserData,
		arg.PostID,
	)
	var i PostReaction
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.IpAddr,
		&i.UserAgent,
		&i.Locale,
		&i.Reaction,
		&i.PostID,
		&i.CreatedOn,
		&i.UserData,
		&i.UserID,
		&i.UserName,
		&i.UserEmail,
		&i.UserRole,
	)
	return i, err
}

const insertRoadmapPost = `-- name: InsertRoadmapPost :one
INSERT INTO roadmap_posts (title, body, due_date, is_private, author_id, is_idea, user_uuid, board_id, status_id, project_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, user_uuid, is_idea
`

type InsertRoadmapPostParams struct {
	Title     string
	Body      string
	DueDate   sql.NullTime
	IsPrivate bool
	AuthorID  sql.NullInt32
	IsIdea    bool
	UserUuid  uuid.NullUUID
	BoardID   sql.NullInt32
	StatusID  sql.NullInt32
	ProjectID int32
}

func (q *Queries) InsertRoadmapPost(ctx context.Context, arg InsertRoadmapPostParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPost,
		arg.Title,
		arg.Body,
		arg.DueDate,
		arg.IsPrivate,
		arg.AuthorID,
		arg.IsIdea,
		arg.UserUuid,
		arg.BoardID,
		arg.StatusID,
		arg.ProjectID,
	)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.UserUuid,
		&i.IsIdea,
	)
	return i, err
}

const insertStatus = `-- name: InsertStatus :one
INSERT INTO roadmap_statuses (status, description, color, project_id, created_on, sort_order) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, $5) RETURNING id, status, color, description, created_on, project_id, is_private, sort_order
`

type InsertStatusParams struct {
	Status      string
	Description string
	Color       string
	ProjectID   int32
	SortOrder   int32
}

func (q *Queries) InsertStatus(ctx context.Context, arg InsertStatusParams) (RoadmapStatus, error) {
	row := q.db.QueryRowContext(ctx, insertStatus,
		arg.Status,
		arg.Description,
		arg.Color,
		arg.ProjectID,
		arg.SortOrder,
	)
	var i RoadmapStatus
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Color,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
		&i.IsPrivate,
		&i.SortOrder,
	)
	return i, err
}

const unsetLabels = `-- name: UnsetLabels :many
UPDATE posts SET label_id = NULL WHERE id = $1 AND project_id = $2 RETURNING id
`

type UnsetLabelsParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) UnsetLabels(ctx context.Context, arg UnsetLabelsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, unsetLabels, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAuthor = `-- name: UpdateAuthor :one
UPDATE authors SET first_name = $1, last_name = $2, picture_url = $3 WHERE user_id = $4 and project_id = $5 RETURNING id, first_name, last_name, picture_url, user_id, project_id, created_on, updated_on
`

type UpdateAuthorParams struct {
	FirstName  string
	LastName   string
	PictureUrl sql.NullString
	UserID     uuid.UUID
	ProjectID  int32
}

func (q *Queries) UpdateAuthor(ctx context.Context, arg UpdateAuthorParams) (Author, error) {
	row := q.db.QueryRowContext(ctx, updateAuthor,
		arg.FirstName,
		arg.LastName,
		arg.PictureUrl,
		arg.UserID,
		arg.ProjectID,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PictureUrl,
		&i.UserID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updateBoard = `-- name: UpdateBoard :one
UPDATE roadmap_boards SET name = $1, is_private = $2, description = $3 WHERE id = $4 AND project_id = $5 RETURNING id, name, is_private, description, created_on, project_id
`

type UpdateBoardParams struct {
	Name        string
	IsPrivate   bool
	Description string
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) (RoadmapBoard, error) {
	row := q.db.QueryRowContext(ctx, updateBoard,
		arg.Name,
		arg.IsPrivate,
		arg.Description,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapBoard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsPrivate,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
	)
	return i, err
}

const updateLabel = `-- name: UpdateLabel :one
UPDATE labels SET label = $1, color = $2 WHERE id = $3 AND project_id = $4 RETURNING id, label, color, project_id, created_on, updated_on
`

type UpdateLabelParams struct {
	Label     string
	Color     string
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateLabel(ctx context.Context, arg UpdateLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, updateLabel,
		arg.Label,
		arg.Color,
		arg.ID,
		arg.ProjectID,
	)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts SET title = $1, body = $2, published_on = $3, is_published = $4, label_id = $5, expires_on = $6, updated_on = CURRENT_TIMESTAMP WHERE id = $7 AND project_id = $8 RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id, is_published, expires_on
`

type UpdatePostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	IsPublished sql.NullBool
	LabelID     sql.NullInt32
	ExpiresOn   sql.NullTime
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.IsPublished,
		arg.LabelID,
		arg.ExpiresOn,
		arg.ID,
		arg.ProjectID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET name = $1, description = $2, accent_color = $3, logo_url = $4, updated_on = CURRENT_TIMESTAMP WHERE id = $5 AND user_id = $6 RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type UpdateProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	ID          int32
	UserID      uuid.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updateReaction = `-- name: UpdateReaction :one
UPDATE post_reactions SET reaction = $1 WHERE user_uuid = $2 AND post_id = $3 AND reaction IS NOT NULL RETURNING id, user_uuid, ip_addr, user_agent, locale, reaction, post_id, created_on, user_data, user_id, user_name, user_email, user_role
`

type UpdateReactionParams struct {
	Reaction sql.NullString
	UserUuid uuid.UUID
	PostID   int32
}

func (q *Queries) UpdateReaction(ctx context.Context, arg UpdateReactionParams) (PostReaction, error) {
	row := q.db.QueryRowContext(ctx, updateReaction, arg.Reaction, arg.UserUuid, arg.PostID)
	var i PostReaction
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.IpAddr,
		&i.UserAgent,
		&i.Locale,
		&i.Reaction,
		&i.PostID,
		&i.CreatedOn,
		&i.UserData,
		&i.UserID,
		&i.UserName,
		&i.UserEmail,
		&i.UserRole,
	)
	return i, err
}

const updateRoadmapPost = `-- name: UpdateRoadmapPost :one
UPDATE roadmap_posts SET title = $1, body = $2, due_date = $3, is_private = $4, board_id = $5, status_id = $6 WHERE id = $7 AND project_id = $8 RETURNING id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, user_uuid, is_idea
`

type UpdateRoadmapPostParams struct {
	Title     string
	Body      string
	DueDate   sql.NullTime
	IsPrivate bool
	BoardID   sql.NullInt32
	StatusID  sql.NullInt32
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateRoadmapPost(ctx context.Context, arg UpdateRoadmapPostParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, updateRoadmapPost,
		arg.Title,
		arg.Body,
		arg.DueDate,
		arg.IsPrivate,
		arg.BoardID,
		arg.StatusID,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.UserUuid,
		&i.IsIdea,
	)
	return i, err
}

const updateStatus = `-- name: UpdateStatus :one
UPDATE roadmap_statuses SET status = $1, description = $2, color = $3 WHERE id = $4 AND project_id = $5 RETURNING id, status, color, description, created_on, project_id, is_private, sort_order
`

type UpdateStatusParams struct {
	Status      string
	Description string
	Color       string
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) (RoadmapStatus, error) {
	row := q.db.QueryRowContext(ctx, updateStatus,
		arg.Status,
		arg.Description,
		arg.Color,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapStatus
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Color,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
		&i.IsPrivate,
		&i.SortOrder,
	)
	return i, err
}

const updateStatusOrder = `-- name: UpdateStatusOrder :one
UPDATE roadmap_statuses SET sort_order = $1 WHERE id = $2 AND project_id = $3 RETURNING id, status, sort_order, color
`

type UpdateStatusOrderParams struct {
	SortOrder int32
	ID        int32
	ProjectID int32
}

type UpdateStatusOrderRow struct {
	ID        int32
	Status    string
	SortOrder int32
	Color     string
}

func (q *Queries) UpdateStatusOrder(ctx context.Context, arg UpdateStatusOrderParams) (UpdateStatusOrderRow, error) {
	row := q.db.QueryRowContext(ctx, updateStatusOrder, arg.SortOrder, arg.ID, arg.ProjectID)
	var i UpdateStatusOrderRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SortOrder,
		&i.Color,
	)
	return i, err
}

const userViewed = `-- name: UserViewed :one
SELECT COUNT(id) FROM post_reactions WHERE user_uuid = $1 AND post_id = $2 AND reaction IS NULL
`

type UserViewedParams struct {
	UserUuid uuid.UUID
	PostID   int32
}

func (q *Queries) UserViewed(ctx context.Context, arg UserViewedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, userViewed, arg.UserUuid, arg.PostID)
	var count int64
	err := row.Scan(&count)
	return count, err
}
