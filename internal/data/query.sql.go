// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteLabel = `-- name: DeleteLabel :one
DELETE FROM labels WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeleteLabelParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteLabel(ctx context.Context, arg DeleteLabelParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteLabel, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deletePost = `-- name: DeletePost :one
DELETE FROM posts WHERE id = $1 AND author_id = $2 RETURNING id
`

type DeletePostParams struct {
	ID       int32
	AuthorID uuid.UUID
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deletePost, arg.ID, arg.AuthorID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getLabels = `-- name: GetLabels :many
SELECT id, label, color, project_id, created_on, updated_on from labels WHERE project_id = $1 ORDER BY created_on
`

// LABELS --
func (q *Queries) GetLabels(ctx context.Context, projectID int32) ([]Label, error) {
	rows, err := q.db.QueryContext(ctx, getLabels, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Label
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Color,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one
SELECT p.id, p.title, p.body, p.published_on, p.author_id, p.project_id, p.created_on, p.updated_on, p.label_id, l.label as Label FROM posts p LEFT JOIN labels l on p.label_id = l.id WHERE p.id = $1 AND author_id = $2
`

type GetPostParams struct {
	ID       int32
	AuthorID uuid.UUID
}

type GetPostRow struct {
	ID          int32
	Title       string
	Body        string
	PublishedOn time.Time
	AuthorID    uuid.UUID
	ProjectID   int32
	CreatedOn   time.Time
	UpdatedOn   sql.NullTime
	LabelID     sql.NullInt32
	Label       sql.NullString
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (GetPostRow, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.ID, arg.AuthorID)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.Label,
	)
	return i, err
}

const getPostCount = `-- name: GetPostCount :one
SELECT COUNT(id) total_posts FROM posts WHERE author_id = $1
`

// POSTS --
func (q *Queries) GetPostCount(ctx context.Context, authorID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostCount, authorID)
	var total_posts int64
	err := row.Scan(&total_posts)
	return total_posts, err
}

const getPosts = `-- name: GetPosts :many
SELECT id, title, published_on FROM posts WHERE author_id = $1
`

type GetPostsRow struct {
	ID          int32
	Title       string
	PublishedOn time.Time
}

func (q *Queries) GetPosts(ctx context.Context, authorID uuid.UUID) ([]GetPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPosts, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsRow
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(&i.ID, &i.Title, &i.PublishedOn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :many
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects WHERE user_id = $1 LIMIT 1
`

// PROJECTS --
func (q *Queries) GetProject(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProject, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AccentColor,
			&i.LogoUrl,
			&i.AppKey,
			&i.UserID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByKey = `-- name: GetProjectByKey :one
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects where app_key = $1 LIMIT 1
`

func (q *Queries) GetProjectByKey(ctx context.Context, appKey string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByKey, appKey)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const getPublishedPagedPosts = `-- name: GetPublishedPagedPosts :many
SELECT post.id, post.title, post.body, post.published_on, post.author_id, post.project_id, post.created_on, post.updated_on, post.label_id FROM posts post join projects proj on post.project_id = proj.id WHERE proj.app_key = $1 AND post.published_on <= CURRENT_TIMESTAMP ORDER BY post.published_on DESC LIMIT $2 OFFSET $3
`

type GetPublishedPagedPostsParams struct {
	AppKey string
	Limit  int32
	Offset int32
}

func (q *Queries) GetPublishedPagedPosts(ctx context.Context, arg GetPublishedPagedPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPublishedPagedPosts, arg.AppKey, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.PublishedOn,
			&i.AuthorID,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.LabelID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLabel = `-- name: InsertLabel :one
INSERT INTO labels (label, color, project_id) VALUES ($1, $2, $3) RETURNING id, label, color, project_id, created_on, updated_on
`

type InsertLabelParams struct {
	Label     string
	Color     string
	ProjectID int32
}

func (q *Queries) InsertLabel(ctx context.Context, arg InsertLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, insertLabel, arg.Label, arg.Color, arg.ProjectID)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO posts (title, body, published_on, label_id, author_id, project_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id
`

type InsertPostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	LabelID     sql.NullInt32
	AuthorID    uuid.UUID
	ProjectID   int32
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, insertPost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.LabelID,
		arg.AuthorID,
		arg.ProjectID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
	)
	return i, err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO projects (name, description, accent_color, logo_url, app_key, user_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type InsertProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	AppKey      string
	UserID      uuid.UUID
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, insertProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.AppKey,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const unsetLabels = `-- name: UnsetLabels :many
UPDATE posts SET label_id = NULL WHERE id = $1 AND project_id = $2 RETURNING id
`

type UnsetLabelsParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) UnsetLabels(ctx context.Context, arg UnsetLabelsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, unsetLabels, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLabel = `-- name: UpdateLabel :one
UPDATE labels SET label = $1, color = $2 WHERE id = $3 AND project_id = $4 RETURNING id, label, color, project_id, created_on, updated_on
`

type UpdateLabelParams struct {
	Label     string
	Color     string
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateLabel(ctx context.Context, arg UpdateLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, updateLabel,
		arg.Label,
		arg.Color,
		arg.ID,
		arg.ProjectID,
	)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts SET title = $1, body = $2, published_on = $3, label_id = $4, updated_on = CURRENT_TIMESTAMP WHERE id = $5 AND author_id = $6 RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id
`

type UpdatePostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	LabelID     sql.NullInt32
	ID          int32
	AuthorID    uuid.UUID
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.LabelID,
		arg.ID,
		arg.AuthorID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET name = $1, description = $2, accent_color = $3, logo_url = $4, updated_on = CURRENT_TIMESTAMP WHERE id = $5 AND user_id = $6 RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type UpdateProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	ID          int32
	UserID      uuid.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}
