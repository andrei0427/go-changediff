// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const analyticsUsers = `-- name: AnalyticsUsers :many
SELECT DISTINCT 
   COALESCE(REPLACE(v.user_id, '"', ''), 'N/A') as UserID,
   v.user_uuid,
   v.id,
   COALESCE(REPLACE(v.user_name, '"', ''), 'User') as UserName, 
   COALESCE(REPLACE(v.user_email, '"', ''), 'N/A') as UserEmail, 
   COALESCE(REPLACE(v.user_role, '"', ''), 'N/A') as UserRole, 
   v.locale,
   CAST(STRING_AGG(distinct v.ip_addr, ',') as text) as IPAddress,
   CAST(STRING_AGG(distinct v.user_agent, ',') as text) as UserAgent,
   CASE WHEN v.user_data IS NOT NULL THEN CAST(v.user_data as text) ELSE NULL END as UserData,
   COUNT(DISTINCT civ.id) as ViewCount, 
   COUNT(DISTINCT cir.id) as ImpressionCount, 
   COUNT(DISTINCT cic.id) as CommentCount 
FROM viewers v 
  LEFT JOIN changelog_interactions civ on (civ.project_id = $1 and civ.viewer_id = v.id and civ.interaction_type_id = 1) or civ.id is null
  LEFT JOIN changelog_interactions cir on (cir.project_id = $1 and cir.viewer_id = v.id and cir.interaction_type_id = 2) or cir.id is null
  LEFT JOIN changelog_interactions cic on (cic.project_id = $1 and cic.viewer_id = v.id and cic.interaction_type_id = 3) or cic.id is null
WHERE $2 = 0 OR v.id = $2
GROUP BY v.user_id, v.user_uuid, v.id, UserName, UserEmail, UserRole, v.locale, UserData
`

type AnalyticsUsersParams struct {
	ProjectID int32
	Column2   interface{}
}

type AnalyticsUsersRow struct {
	Userid          interface{}
	UserUuid        uuid.UUID
	ID              int32
	Username        interface{}
	Useremail       interface{}
	Userrole        interface{}
	Locale          string
	Ipaddress       string
	Useragent       string
	Userdata        interface{}
	Viewcount       int64
	Impressioncount int64
	Commentcount    int64
}

func (q *Queries) AnalyticsUsers(ctx context.Context, arg AnalyticsUsersParams) ([]AnalyticsUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, analyticsUsers, arg.ProjectID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyticsUsersRow
	for rows.Next() {
		var i AnalyticsUsersRow
		if err := rows.Scan(
			&i.Userid,
			&i.UserUuid,
			&i.ID,
			&i.Username,
			&i.Useremail,
			&i.Userrole,
			&i.Locale,
			&i.Ipaddress,
			&i.Useragent,
			&i.Userdata,
			&i.Viewcount,
			&i.Impressioncount,
			&i.Commentcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dashboardQuery = `-- name: DashboardQuery :one
SELECT COUNT(p.id), COUNT(civ.id), COUNT(cic.id) 
  FROM posts p 
    left join changelog_interactions civ on p.id = civ.post_id and (civ.id is null or civ.interaction_type_id = 1)
    left join changelog_interactions cic on p.id = cic.post_id and (cic.id is null or cic.interaction_type_id = 3) 
  WHERE p.project_id = $1
`

type DashboardQueryRow struct {
	Count   int64
	Count_2 int64
	Count_3 int64
}

func (q *Queries) DashboardQuery(ctx context.Context, projectID int32) (DashboardQueryRow, error) {
	row := q.db.QueryRowContext(ctx, dashboardQuery, projectID)
	var i DashboardQueryRow
	err := row.Scan(&i.Count, &i.Count_2, &i.Count_3)
	return i, err
}

const deleteAllRoadmapPostComments = `-- name: DeleteAllRoadmapPostComments :many
delete from roadmap_post_comments rpc 
  using roadmap_posts rp
   where rpc.roadmap_post_id = rp.id 
     and rp.id = $1 
     and rp.project_id = $2 
RETURNING rpc.id
`

type DeleteAllRoadmapPostCommentsParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteAllRoadmapPostComments(ctx context.Context, arg DeleteAllRoadmapPostCommentsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteAllRoadmapPostComments, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteBoard = `-- name: DeleteBoard :one
DELETE FROM roadmap_boards WHERE id = $1 and project_id = $2 RETURNING id
`

type DeleteBoardParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteBoard(ctx context.Context, arg DeleteBoardParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteBoard, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteInteractions = `-- name: DeleteInteractions :many
DELETE FROM changelog_interactions WHERE post_id = $1 AND project_id = $2 RETURNING id
`

type DeleteInteractionsParams struct {
	PostID    int32
	ProjectID int32
}

func (q *Queries) DeleteInteractions(ctx context.Context, arg DeleteInteractionsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteInteractions, arg.PostID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteLabel = `-- name: DeleteLabel :one
DELETE FROM labels WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeleteLabelParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteLabel(ctx context.Context, arg DeleteLabelParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteLabel, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deletePost = `-- name: DeletePost :one
DELETE FROM posts WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeletePostParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deletePost, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteRoadmapPost = `-- name: DeleteRoadmapPost :one
DELETE FROM roadmap_posts WHERE id = $1 AND project_id = $2 RETURNING id
`

type DeleteRoadmapPostParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteRoadmapPost(ctx context.Context, arg DeleteRoadmapPostParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteRoadmapPost, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteRoadmapPostActivity = `-- name: DeleteRoadmapPostActivity :many
delete from roadmap_post_activity rpa 
   using roadmap_posts rp 
   where rpa.roadmap_post_id = rp.id 
     and rp.id = $1 
     and rp.project_id = $2
     and ($3 = 0 OR rp.author_id = $3)
     and ($4 = 0 OR rp.viewer_id = $4)
RETURNING rpa.id
`

type DeleteRoadmapPostActivityParams struct {
	ID        int32
	ProjectID int32
	Column3   interface{}
	Column4   interface{}
}

func (q *Queries) DeleteRoadmapPostActivity(ctx context.Context, arg DeleteRoadmapPostActivityParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteRoadmapPostActivity,
		arg.ID,
		arg.ProjectID,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRoadmapPostCategoriesByPost = `-- name: DeleteRoadmapPostCategoriesByPost :many
DELETE FROM roadmap_post_categories where roadmap_post_id = $1 AND project_id = $2 RETURNING id
`

type DeleteRoadmapPostCategoriesByPostParams struct {
	RoadmapPostID int32
	ProjectID     int32
}

func (q *Queries) DeleteRoadmapPostCategoriesByPost(ctx context.Context, arg DeleteRoadmapPostCategoriesByPostParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteRoadmapPostCategoriesByPost, arg.RoadmapPostID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRoadmapPostComment = `-- name: DeleteRoadmapPostComment :one
update roadmap_post_comments rpc 
   set rpc.is_deleted = 1 
   from roadmap_posts rp 
   where rpc.roadmap_post_id = rp.id 
     and rpc.id = $1
     and rp.id = $2 
     and rp.project_id = $3 
     and ($4 = 0 OR rp.author_id = $4)
     and ($5 = 0 OR rp.viewer_id = $5)
RETURNING rpc.id
`

type DeleteRoadmapPostCommentParams struct {
	ID        int32
	ID_2      int32
	ProjectID int32
	Column4   interface{}
	Column5   interface{}
}

func (q *Queries) DeleteRoadmapPostComment(ctx context.Context, arg DeleteRoadmapPostCommentParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteRoadmapPostComment,
		arg.ID,
		arg.ID_2,
		arg.ProjectID,
		arg.Column4,
		arg.Column5,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteRoadmapPostReaction = `-- name: DeleteRoadmapPostReaction :many
delete from roadmap_post_reactions rpr 
   using roadmap_posts rp 
   where rpr.roadmap_post_id = rp.id 
     and ($1 = '' or rpr.emoji = $1)
     and rp.id = $2 
     and rp.project_id = $3 
RETURNING rpr.id
`

type DeleteRoadmapPostReactionParams struct {
	Column1   interface{}
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteRoadmapPostReaction(ctx context.Context, arg DeleteRoadmapPostReactionParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteRoadmapPostReaction, arg.Column1, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRoadmapPostVote = `-- name: DeleteRoadmapPostVote :many
delete from roadmap_post_votes rpv 
   using roadmap_posts rp 
   where rpv.roadmap_post_id = rp.id 
     and ($1 = 0 or rpv.id = $1)
     and rp.id = $2 
     and rp.project_id = $3 
     and ($4 = 0 OR rp.author_id = $4)
     and ($5 = 0 OR rp.viewer_id = $5)
RETURNING rpv.id
`

type DeleteRoadmapPostVoteParams struct {
	Column1   interface{}
	ID        int32
	ProjectID int32
	Column4   interface{}
	Column5   interface{}
}

func (q *Queries) DeleteRoadmapPostVote(ctx context.Context, arg DeleteRoadmapPostVoteParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, deleteRoadmapPostVote,
		arg.Column1,
		arg.ID,
		arg.ProjectID,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteStatus = `-- name: DeleteStatus :one
DELETE FROM roadmap_statuses WHERE id = $1 and project_id = $2 RETURNING id
`

type DeleteStatusParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) DeleteStatus(ctx context.Context, arg DeleteStatusParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, deleteStatus, arg.ID, arg.ProjectID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getAuthorByUser = `-- name: GetAuthorByUser :many
SELECT a.id, a.first_name, a.last_name, a.picture_url, a.user_id, a.project_id, a.created_on, a.updated_on, 
   s.id, s.subscription_start_date, s.is_annual, s.tier, 
   CASE 
    WHEN s.is_annual = false 
      THEN (s.subscription_start_date + INTERVAL '1 month') >= CURRENT_TIMESTAMP
    WHEN s.is_annual = true 
      THEN (s.subscription_start_date + INTERVAL '1 year') >= CURRENT_TIMESTAMP 
    ELSE false END as is_active,
   CASE 
    WHEN s.is_annual = false 
      THEN s.subscription_start_date + INTERVAL '1 month'
    WHEN s.is_annual = true 
      THEN s.subscription_start_date + INTERVAL '1 year'
    ELSE NULL END as expires_on
FROM authors a
  LEFT JOIN subscriptions s on 
    (a.id = s.subscriber_id and 
     s.subscription_start_date <= current_timestamp and
     s.success = true and
     s.stopped = false 
    ) 
    or s.id is null
WHERE a.user_id = $1
ORDER BY s.subscription_start_date DESC
LIMIT 1
`

type GetAuthorByUserRow struct {
	ID                    int32
	FirstName             string
	LastName              string
	PictureUrl            sql.NullString
	UserID                uuid.UUID
	ProjectID             int32
	CreatedOn             time.Time
	UpdatedOn             sql.NullTime
	ID_2                  sql.NullInt32
	SubscriptionStartDate sql.NullTime
	IsAnnual              sql.NullBool
	Tier                  sql.NullInt32
	IsActive              bool
	ExpiresOn             interface{}
}

// AUTHOR --
func (q *Queries) GetAuthorByUser(ctx context.Context, userID uuid.UUID) ([]GetAuthorByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAuthorByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAuthorByUserRow
	for rows.Next() {
		var i GetAuthorByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.UserID,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.ID_2,
			&i.SubscriptionStartDate,
			&i.IsAnnual,
			&i.Tier,
			&i.IsActive,
			&i.ExpiresOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBoard = `-- name: GetBoard :one
SELECT id, name, description, is_private FROM roadmap_boards WHERE id = $1 AND project_id = $2
`

type GetBoardParams struct {
	ID        int32
	ProjectID int32
}

type GetBoardRow struct {
	ID          int32
	Name        string
	Description string
	IsPrivate   bool
}

func (q *Queries) GetBoard(ctx context.Context, arg GetBoardParams) (GetBoardRow, error) {
	row := q.db.QueryRowContext(ctx, getBoard, arg.ID, arg.ProjectID)
	var i GetBoardRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
	)
	return i, err
}

const getBoards = `-- name: GetBoards :many

SELECT id, name, is_private FROM roadmap_boards WHERE project_id = $1 order by created_on
`

type GetBoardsRow struct {
	ID        int32
	Name      string
	IsPrivate bool
}

// ROADMAP --
func (q *Queries) GetBoards(ctx context.Context, projectID int32) ([]GetBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBoards, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBoardsRow
	for rows.Next() {
		var i GetBoardsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.IsPrivate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLabels = `-- name: GetLabels :many
SELECT id, label, color, project_id, created_on, updated_on from labels WHERE project_id = $1 ORDER BY created_on
`

// LABELS --
func (q *Queries) GetLabels(ctx context.Context, projectID int32) ([]Label, error) {
	rows, err := q.db.QueryContext(ctx, getLabels, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Label
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Color,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextSortOrderForStatus = `-- name: GetNextSortOrderForStatus :one
SELECT MAX(COALESCE(sort_order, 0)) + 1 as NextSortOrder FROM roadmap_statuses WHERE project_id = $1
`

func (q *Queries) GetNextSortOrderForStatus(ctx context.Context, projectID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextSortOrderForStatus, projectID)
	var nextsortorder int32
	err := row.Scan(&nextsortorder)
	return nextsortorder, err
}

const getPost = `-- name: GetPost :one
SELECT p.id, p.title, p.body, p.published_on, p.author_id, p.project_id, p.created_on, p.updated_on, p.label_id, p.is_published, p.expires_on, l.label as Label FROM posts p LEFT JOIN labels l on p.label_id = l.id or p.label_id is null WHERE p.id = $1 AND p.project_id = $2
`

type GetPostParams struct {
	ID        int32
	ProjectID int32
}

type GetPostRow struct {
	ID          int32
	Title       string
	Body        string
	PublishedOn time.Time
	AuthorID    int32
	ProjectID   int32
	CreatedOn   time.Time
	UpdatedOn   sql.NullTime
	LabelID     sql.NullInt32
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (GetPostRow, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.ID, arg.ProjectID)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
		&i.Label,
	)
	return i, err
}

const getPostComments = `-- name: GetPostComments :many
SELECT p.id, 
       p.title, 
       ci.content, 
       ci.created_on, 
       v.locale, 
       r.content as Reaction, 
       REPLACE(v.user_name, '"', '') as UserName, 
       REPLACE(v.user_role, '"', '') as UserRole
	FROM posts p 
		JOIN changelog_interactions ci ON ci.post_id = p.id AND ci.interaction_type_id = 3
		JOIN viewers v ON v.id = ci.viewer_id 
		LEFT JOIN changelog_interactions r ON (r.post_id = p.id AND r.viewer_id = v.id AND r.interaction_type_id = 2) OR r.id is null
WHERE p.project_id = $1
    and ($2 = 0 OR v.id = $2)
    and ($3 = 0 OR p.id = $3)
ORDER BY ci.created_on DESC
`

type GetPostCommentsParams struct {
	ProjectID int32
	Column2   interface{}
	Column3   interface{}
}

type GetPostCommentsRow struct {
	ID        int32
	Title     string
	Content   sql.NullString
	CreatedOn time.Time
	Locale    string
	Reaction  sql.NullString
	Username  string
	Userrole  string
}

func (q *Queries) GetPostComments(ctx context.Context, arg GetPostCommentsParams) ([]GetPostCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostComments, arg.ProjectID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostCommentsRow
	for rows.Next() {
		var i GetPostCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.CreatedOn,
			&i.Locale,
			&i.Reaction,
			&i.Username,
			&i.Userrole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostCount = `-- name: GetPostCount :one
SELECT COUNT(id) total_posts FROM posts WHERE project_id = $1
`

// POSTS --
func (q *Queries) GetPostCount(ctx context.Context, projectID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostCount, projectID)
	var total_posts int64
	err := row.Scan(&total_posts)
	return total_posts, err
}

const getPostReactions = `-- name: GetPostReactions :many
SELECT 
  CASE WHEN ci.content IS NULL THEN '' ELSE ci.content END as Reaction, 
  COUNT(ci.*) 
FROM changelog_interactions ci 
WHERE ci.project_id = $1 
  AND ($2 = 0 OR ci.post_id = $2)
  AND ($3 = 0 OR ci.viewer_id = $3)
GROUP BY ci.content
ORDER BY ci.content NULLS FIRST
`

type GetPostReactionsParams struct {
	ProjectID int32
	Column2   interface{}
	Column3   interface{}
}

type GetPostReactionsRow struct {
	Reaction interface{}
	Count    int64
}

func (q *Queries) GetPostReactions(ctx context.Context, arg GetPostReactionsParams) ([]GetPostReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostReactions, arg.ProjectID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostReactionsRow
	for rows.Next() {
		var i GetPostReactionsRow
		if err := rows.Scan(&i.Reaction, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPosts = `-- name: GetPosts :many
SELECT p.id, p.title, p.published_on, p.is_published, p.expires_on, l.label, l.color, 
  CASE WHEN p.published_on <= current_timestamp THEN 
    CASE WHEN p.expires_on is not null and p.expires_on <= current_timestamp THEN 2 
       ELSE 1 END 
      ELSE 0 END AS status, 
  COUNT(r.id) as ViewCount FROM posts p 
       left join labels l on p.label_id = l.id 
       left join changelog_interactions r on (p.id = r.post_id and r.interaction_type_id = 1) OR r.id is null 
  WHERE p.project_id = $1
  GROUP BY 1,2,3,4,5,6,7
  ORDER BY p.published_on DESC
`

type GetPostsRow struct {
	ID          int32
	Title       string
	PublishedOn time.Time
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
	Color       sql.NullString
	Status      int32
	Viewcount   int64
}

func (q *Queries) GetPosts(ctx context.Context, projectID int32) ([]GetPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPosts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsRow
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PublishedOn,
			&i.IsPublished,
			&i.ExpiresOn,
			&i.Label,
			&i.Color,
			&i.Status,
			&i.Viewcount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsForBoard = `-- name: GetPostsForBoard :many
SELECT rp.id, title, body, due_date, board_id, rp.project_id, status_id, rp.created_on, is_private, author_id, viewer_id, is_idea, is_pinned, is_locked, a.id, first_name, last_name, picture_url, a.user_id, a.project_id, a.created_on, updated_on, v.id, user_uuid, ip_addr, user_agent, locale, user_data, v.user_id, user_name, user_email, user_role, v.project_id, v.created_on
from roadmap_posts rp 
  left join authors a on a.id = rp.author_id
  left join viewers v on v.id = rp.viewer_id
where (rp.board_id IS NULL OR rp.board_id = $1) and rp.project_id = $2
order by due_date
`

type GetPostsForBoardParams struct {
	BoardID   sql.NullInt32
	ProjectID int32
}

type GetPostsForBoardRow struct {
	ID          int32
	Title       string
	Body        string
	DueDate     sql.NullTime
	BoardID     sql.NullInt32
	ProjectID   int32
	StatusID    sql.NullInt32
	CreatedOn   time.Time
	IsPrivate   bool
	AuthorID    sql.NullInt32
	ViewerID    sql.NullInt32
	IsIdea      bool
	IsPinned    bool
	IsLocked    bool
	ID_2        sql.NullInt32
	FirstName   sql.NullString
	LastName    sql.NullString
	PictureUrl  sql.NullString
	UserID      uuid.NullUUID
	ProjectID_2 sql.NullInt32
	CreatedOn_2 sql.NullTime
	UpdatedOn   sql.NullTime
	ID_3        sql.NullInt32
	UserUuid    uuid.NullUUID
	IpAddr      sql.NullString
	UserAgent   sql.NullString
	Locale      sql.NullString
	UserData    pqtype.NullRawMessage
	UserID_2    sql.NullString
	UserName    sql.NullString
	UserEmail   sql.NullString
	UserRole    sql.NullString
	ProjectID_3 sql.NullInt32
	CreatedOn_3 sql.NullTime
}

func (q *Queries) GetPostsForBoard(ctx context.Context, arg GetPostsForBoardParams) ([]GetPostsForBoardRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsForBoard, arg.BoardID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsForBoardRow
	for rows.Next() {
		var i GetPostsForBoardRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.DueDate,
			&i.BoardID,
			&i.ProjectID,
			&i.StatusID,
			&i.CreatedOn,
			&i.IsPrivate,
			&i.AuthorID,
			&i.ViewerID,
			&i.IsIdea,
			&i.IsPinned,
			&i.IsLocked,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.UserID,
			&i.ProjectID_2,
			&i.CreatedOn_2,
			&i.UpdatedOn,
			&i.ID_3,
			&i.UserUuid,
			&i.IpAddr,
			&i.UserAgent,
			&i.Locale,
			&i.UserData,
			&i.UserID_2,
			&i.UserName,
			&i.UserEmail,
			&i.UserRole,
			&i.ProjectID_3,
			&i.CreatedOn_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProject = `-- name: GetProject :many
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects WHERE user_id = $1 LIMIT 1
`

// PROJECTS --
func (q *Queries) GetProject(ctx context.Context, userID uuid.UUID) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProject, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AccentColor,
			&i.LogoUrl,
			&i.AppKey,
			&i.UserID,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByKey = `-- name: GetProjectByKey :one
SELECT id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on FROM projects where app_key = $1 LIMIT 1
`

func (q *Queries) GetProjectByKey(ctx context.Context, appKey string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByKey, appKey)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const getPublishedPagedPosts = `-- name: GetPublishedPagedPosts :many
SELECT distinct post.id, post.title, post.body, post.published_on, post.author_id, post.project_id, post.created_on, post.updated_on, post.label_id, post.is_published, post.expires_on, l.label, l.color, a.first_name, a.last_name, a.picture_url, r.content as Reaction, 
      CASE WHEN v.id IS NULL THEN 0 ELSE 1 END as Viewed
  FROM posts post 
    join projects proj on post.project_id = proj.id 
	  join authors a on a.id = post.author_id 
    left join labels l on post.label_id = l.id or post.label_id is null 
    left join changelog_interactions r on (r.post_id = post.id and r.interaction_type_id = 2 and r.viewer_id = $4) or r.id is null
    left join changelog_interactions v on (v.post_id = post.id and v.interaction_type_id = 1 and v.viewer_id = $4) or v.id is null 
WHERE proj.app_key = $1 
   AND post.published_on <= CURRENT_TIMESTAMP 
   AND (post.expires_on IS NULL OR post.expires_on >= CURRENT_TIMESTAMP)
   AND post.is_published = true
   AND ($5 = '' OR LOWER(post.title) LIKE $5)
ORDER BY post.published_on DESC 
LIMIT $2 
OFFSET $3
`

type GetPublishedPagedPostsParams struct {
	AppKey   string
	Limit    int32
	Offset   int32
	ViewerID int32
	Column5  interface{}
}

type GetPublishedPagedPostsRow struct {
	ID          int32
	Title       string
	Body        string
	PublishedOn time.Time
	AuthorID    int32
	ProjectID   int32
	CreatedOn   time.Time
	UpdatedOn   sql.NullTime
	LabelID     sql.NullInt32
	IsPublished sql.NullBool
	ExpiresOn   sql.NullTime
	Label       sql.NullString
	Color       sql.NullString
	FirstName   string
	LastName    string
	PictureUrl  sql.NullString
	Reaction    sql.NullString
	Viewed      int32
}

func (q *Queries) GetPublishedPagedPosts(ctx context.Context, arg GetPublishedPagedPostsParams) ([]GetPublishedPagedPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublishedPagedPosts,
		arg.AppKey,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublishedPagedPostsRow
	for rows.Next() {
		var i GetPublishedPagedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.PublishedOn,
			&i.AuthorID,
			&i.ProjectID,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.LabelID,
			&i.IsPublished,
			&i.ExpiresOn,
			&i.Label,
			&i.Color,
			&i.FirstName,
			&i.LastName,
			&i.PictureUrl,
			&i.Reaction,
			&i.Viewed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReaction = `-- name: GetReaction :many
SELECT content FROM changelog_interactions WHERE post_id = $1 AND viewer_id = $2 AND project_id = $3 AND interaction_type_id = 2
`

type GetReactionParams struct {
	PostID    int32
	ViewerID  int32
	ProjectID int32
}

func (q *Queries) GetReaction(ctx context.Context, arg GetReactionParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getReaction, arg.PostID, arg.ViewerID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var content sql.NullString
		if err := rows.Scan(&content); err != nil {
			return nil, err
		}
		items = append(items, content)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoadmapPost = `-- name: GetRoadmapPost :one
SELECT p.id, p.title, p.is_private, p.body, p.due_date, p.status_id, p.board_id, p.created_on, COUNT(v.id) as Votes FROM roadmap_posts p left join roadmap_post_votes v on p.id = v.roadmap_post_id WHERE p.id = $1 AND p.project_id = $2 GROUP BY p.id, p.title, p.is_private, p.body, p.due_date, p.status_id, p.board_id, p.created_on
`

type GetRoadmapPostParams struct {
	ID        int32
	ProjectID int32
}

type GetRoadmapPostRow struct {
	ID        int32
	Title     string
	IsPrivate bool
	Body      string
	DueDate   sql.NullTime
	StatusID  sql.NullInt32
	BoardID   sql.NullInt32
	CreatedOn time.Time
	Votes     int64
}

func (q *Queries) GetRoadmapPost(ctx context.Context, arg GetRoadmapPostParams) (GetRoadmapPostRow, error) {
	row := q.db.QueryRowContext(ctx, getRoadmapPost, arg.ID, arg.ProjectID)
	var i GetRoadmapPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsPrivate,
		&i.Body,
		&i.DueDate,
		&i.StatusID,
		&i.BoardID,
		&i.CreatedOn,
		&i.Votes,
	)
	return i, err
}

const getRoadmapPostActivity = `-- name: GetRoadmapPostActivity :one
select
  p.id as ID,
  a.first_name as Who,
  p.created_on as CreatedOn,
  a.picture_url as WhoPictureUrl
from roadmap_posts p 
  join authors a on a.id = p.author_id
where p.id = $1 and p.project_id = $2
`

type GetRoadmapPostActivityParams struct {
	ID        int32
	ProjectID int32
}

type GetRoadmapPostActivityRow struct {
	ID            int32
	Who           string
	Createdon     time.Time
	Whopictureurl sql.NullString
}

func (q *Queries) GetRoadmapPostActivity(ctx context.Context, arg GetRoadmapPostActivityParams) (GetRoadmapPostActivityRow, error) {
	row := q.db.QueryRowContext(ctx, getRoadmapPostActivity, arg.ID, arg.ProjectID)
	var i GetRoadmapPostActivityRow
	err := row.Scan(
		&i.ID,
		&i.Who,
		&i.Createdon,
		&i.Whopictureurl,
	)
	return i, err
}

const getRoadmapPostComments = `-- name: GetRoadmapPostComments :many
select 
   c.id as ID,
   COALESCE(a.first_name, v.user_name, 'Someone') as Who,
   a.picture_url as WhoPictureUrl,
   c.content as Comment,
   c.created_on as CreatedOn,
   c.is_pinned as IsPinned,
   c.is_deleted as IsDeleted,
   COUNT(rc.id) as ReplyCount
from
  roadmap_post_comments c
    inner join roadmap_posts p on p.id = c.roadmap_post_id
    left join authors a on a.id = c.author_id
    left join viewers v on v.id = c.viewer_id
    left join roadmap_post_comments rc on rc.in_reply_to_id = c.id
where c.roadmap_post_id = $1 
    and (($2 = 0 and c.in_reply_to_id is null) or $2 = c.in_reply_to_id)
    and p.project_id = $3
group by
  c.id, Who, WhoPictureUrl, Comment, CreatedOn, IsPinned, IsDeleted
`

type GetRoadmapPostCommentsParams struct {
	RoadmapPostID int32
	Column2       interface{}
	ProjectID     int32
}

type GetRoadmapPostCommentsRow struct {
	ID            int32
	Who           string
	Whopictureurl sql.NullString
	Comment       string
	Createdon     time.Time
	Ispinned      bool
	Isdeleted     bool
	Replycount    int64
}

func (q *Queries) GetRoadmapPostComments(ctx context.Context, arg GetRoadmapPostCommentsParams) ([]GetRoadmapPostCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoadmapPostComments, arg.RoadmapPostID, arg.Column2, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoadmapPostCommentsRow
	for rows.Next() {
		var i GetRoadmapPostCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Who,
			&i.Whopictureurl,
			&i.Comment,
			&i.Createdon,
			&i.Ispinned,
			&i.Isdeleted,
			&i.Replycount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoadmapPostOwner = `-- name: GetRoadmapPostOwner :one
select author_id, viewer_id from roadmap_post_votes where id = $1
`

type GetRoadmapPostOwnerRow struct {
	AuthorID sql.NullInt32
	ViewerID sql.NullInt32
}

func (q *Queries) GetRoadmapPostOwner(ctx context.Context, id int32) (GetRoadmapPostOwnerRow, error) {
	row := q.db.QueryRowContext(ctx, getRoadmapPostOwner, id)
	var i GetRoadmapPostOwnerRow
	err := row.Scan(&i.AuthorID, &i.ViewerID)
	return i, err
}

const getRoadmapPostReactions = `-- name: GetRoadmapPostReactions :many
select
  string_agg(distinct a.first_name, ',') as Authors,
  string_agg(distinct v.user_name, ',') as Viewers,
  emoji as Reaction,
  count(r.id) as count,
  r.comment_id as CommentID,
  $4 = any (array_agg(a.ID))
  or $5 = any (array_agg(v.ID)) as Reacted
from
  roadmap_post_reactions r
  inner join roadmap_posts p on p.id = r.roadmap_post_id
  left join authors a on r.author_id = a.id
  left join viewers v on r.viewer_id = v.id
  left join roadmap_post_comments c on r.comment_id = c.id
where
  r.roadmap_post_id = $1
  and (($2 = 0 and c.in_reply_to_id is null) or ($2 = r.comment_id and c.in_reply_to_id is not null))
  and p.project_id = $3
  and ($6 = '' OR emoji = $6)
group by
  r.comment_id,
  emoji
`

type GetRoadmapPostReactionsParams struct {
	RoadmapPostID int32
	Column2       interface{}
	ProjectID     int32
	ID            int32
	ID_2          int32
	Column6       interface{}
}

type GetRoadmapPostReactionsRow struct {
	Authors   []byte
	Viewers   []byte
	Reaction  string
	Count     int64
	Commentid sql.NullInt32
	Reacted   sql.NullBool
}

func (q *Queries) GetRoadmapPostReactions(ctx context.Context, arg GetRoadmapPostReactionsParams) ([]GetRoadmapPostReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoadmapPostReactions,
		arg.RoadmapPostID,
		arg.Column2,
		arg.ProjectID,
		arg.ID,
		arg.ID_2,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoadmapPostReactionsRow
	for rows.Next() {
		var i GetRoadmapPostReactionsRow
		if err := rows.Scan(
			&i.Authors,
			&i.Viewers,
			&i.Reaction,
			&i.Count,
			&i.Commentid,
			&i.Reacted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoadmapPostStatusActivity = `-- name: GetRoadmapPostStatusActivity :many
select 
   t.id as ID,
   a.first_name as Who,
   a.picture_url as WhoPictureUrl,
   sf.ID as StatusFromID,
   sf.Status as StatusFrom,
   sf.Color as StatusFromColor,
   sf.Description as StatusFromDescription,
   st.ID as StatusToID,
   st.Status as StatusTo,
   st.Color as StatusToColor,
   st.Description as StatusToDescription,
   t.created_on as CreatedOn
from
  roadmap_post_activity t 
    join authors a on a.id = t.author_id
    join roadmap_posts p on p.id = t.roadmap_post_id
    left join roadmap_statuses sf on sf.id = t.from_status_id
    left join roadmap_statuses st on st.id =  t.to_status_id
where t.roadmap_post_id = $1 and p.project_id = $2
`

type GetRoadmapPostStatusActivityParams struct {
	RoadmapPostID int32
	ProjectID     int32
}

type GetRoadmapPostStatusActivityRow struct {
	ID                    int32
	Who                   string
	Whopictureurl         sql.NullString
	Statusfromid          sql.NullInt32
	Statusfrom            sql.NullString
	Statusfromcolor       sql.NullString
	Statusfromdescription sql.NullString
	Statustoid            sql.NullInt32
	Statusto              sql.NullString
	Statustocolor         sql.NullString
	Statustodescription   sql.NullString
	Createdon             time.Time
}

func (q *Queries) GetRoadmapPostStatusActivity(ctx context.Context, arg GetRoadmapPostStatusActivityParams) ([]GetRoadmapPostStatusActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoadmapPostStatusActivity, arg.RoadmapPostID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoadmapPostStatusActivityRow
	for rows.Next() {
		var i GetRoadmapPostStatusActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.Who,
			&i.Whopictureurl,
			&i.Statusfromid,
			&i.Statusfrom,
			&i.Statusfromcolor,
			&i.Statusfromdescription,
			&i.Statustoid,
			&i.Statusto,
			&i.Statustocolor,
			&i.Statustodescription,
			&i.Createdon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatus = `-- name: GetStatus :one
SELECT id, status, description, sort_order, color FROM roadmap_statuses WHERE id = $1 AND project_id = $2
`

type GetStatusParams struct {
	ID        int32
	ProjectID int32
}

type GetStatusRow struct {
	ID          int32
	Status      string
	Description string
	SortOrder   int32
	Color       string
}

func (q *Queries) GetStatus(ctx context.Context, arg GetStatusParams) (GetStatusRow, error) {
	row := q.db.QueryRowContext(ctx, getStatus, arg.ID, arg.ProjectID)
	var i GetStatusRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Description,
		&i.SortOrder,
		&i.Color,
	)
	return i, err
}

const getStatuses = `-- name: GetStatuses :many
SELECT id, status, sort_order, color FROM roadmap_statuses WHERE project_id = $1 ORDER BY sort_order
`

type GetStatusesRow struct {
	ID        int32
	Status    string
	SortOrder int32
	Color     string
}

func (q *Queries) GetStatuses(ctx context.Context, projectID int32) ([]GetStatusesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStatuses, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStatusesRow
	for rows.Next() {
		var i GetStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.SortOrder,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewer = `-- name: GetViewer :many
SELECT id, user_uuid, ip_addr, user_agent, locale, user_data, user_id, user_name, user_email, user_role, project_id, created_on FROM viewers WHERE user_uuid = $1 OR (user_id IS NULL OR user_id = $2) LIMIT 1
`

type GetViewerParams struct {
	UserUuid uuid.UUID
	UserID   sql.NullString
}

func (q *Queries) GetViewer(ctx context.Context, arg GetViewerParams) ([]Viewer, error) {
	rows, err := q.db.QueryContext(ctx, getViewer, arg.UserUuid, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Viewer
	for rows.Next() {
		var i Viewer
		if err := rows.Scan(
			&i.ID,
			&i.UserUuid,
			&i.IpAddr,
			&i.UserAgent,
			&i.Locale,
			&i.UserData,
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.UserRole,
			&i.ProjectID,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getViewersByProject = `-- name: GetViewersByProject :many
SELECT id, user_uuid, ip_addr, user_agent, locale, user_data, user_id, user_name, user_email, user_role, project_id, created_on FROM viewers WHERE project_id = $1 ORDER BY created_on DESC
`

func (q *Queries) GetViewersByProject(ctx context.Context, projectID int32) ([]Viewer, error) {
	rows, err := q.db.QueryContext(ctx, getViewersByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Viewer
	for rows.Next() {
		var i Viewer
		if err := rows.Scan(
			&i.ID,
			&i.UserUuid,
			&i.IpAddr,
			&i.UserAgent,
			&i.Locale,
			&i.UserData,
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.UserRole,
			&i.ProjectID,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPostsForBoard = `-- name: HasPostsForBoard :one
SELECT COUNT(*) FROM roadmap_posts WHERE board_id = $1
`

func (q *Queries) HasPostsForBoard(ctx context.Context, boardID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasPostsForBoard, boardID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const hasPostsForStatus = `-- name: HasPostsForStatus :one
SELECT COUNT(*) FROM roadmap_posts WHERE status_id = $1
`

func (q *Queries) HasPostsForStatus(ctx context.Context, statusID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasPostsForStatus, statusID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertAuthor = `-- name: InsertAuthor :one
INSERT INTO authors (first_name, last_name, picture_url, user_id, project_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, first_name, last_name, picture_url, user_id, project_id, created_on, updated_on
`

type InsertAuthorParams struct {
	FirstName  string
	LastName   string
	PictureUrl sql.NullString
	UserID     uuid.UUID
	ProjectID  int32
}

func (q *Queries) InsertAuthor(ctx context.Context, arg InsertAuthorParams) (Author, error) {
	row := q.db.QueryRowContext(ctx, insertAuthor,
		arg.FirstName,
		arg.LastName,
		arg.PictureUrl,
		arg.UserID,
		arg.ProjectID,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PictureUrl,
		&i.UserID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertBoard = `-- name: InsertBoard :one
INSERT INTO roadmap_boards (name, is_private, description, project_id, created_on) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP) RETURNING id, name, is_private, description, created_on, project_id
`

type InsertBoardParams struct {
	Name        string
	IsPrivate   bool
	Description string
	ProjectID   int32
}

func (q *Queries) InsertBoard(ctx context.Context, arg InsertBoardParams) (RoadmapBoard, error) {
	row := q.db.QueryRowContext(ctx, insertBoard,
		arg.Name,
		arg.IsPrivate,
		arg.Description,
		arg.ProjectID,
	)
	var i RoadmapBoard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsPrivate,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
	)
	return i, err
}

const insertInteraction = `-- name: InsertInteraction :one
INSERT INTO changelog_interactions (content, post_id, interaction_type_id, viewer_id, project_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, content, interaction_type_id, post_id, viewer_id, project_id, created_on
`

type InsertInteractionParams struct {
	Content           sql.NullString
	PostID            int32
	InteractionTypeID int32
	ViewerID          int32
	ProjectID         int32
}

func (q *Queries) InsertInteraction(ctx context.Context, arg InsertInteractionParams) (ChangelogInteraction, error) {
	row := q.db.QueryRowContext(ctx, insertInteraction,
		arg.Content,
		arg.PostID,
		arg.InteractionTypeID,
		arg.ViewerID,
		arg.ProjectID,
	)
	var i ChangelogInteraction
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.InteractionTypeID,
		&i.PostID,
		&i.ViewerID,
		&i.ProjectID,
		&i.CreatedOn,
	)
	return i, err
}

const insertLabel = `-- name: InsertLabel :one
INSERT INTO labels (label, color, project_id) VALUES ($1, $2, $3) RETURNING id, label, color, project_id, created_on, updated_on
`

type InsertLabelParams struct {
	Label     string
	Color     string
	ProjectID int32
}

func (q *Queries) InsertLabel(ctx context.Context, arg InsertLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, insertLabel, arg.Label, arg.Color, arg.ProjectID)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertPost = `-- name: InsertPost :one
INSERT INTO posts (title, body, published_on, is_published, label_id, author_id, project_id) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id, is_published, expires_on
`

type InsertPostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	IsPublished sql.NullBool
	LabelID     sql.NullInt32
	AuthorID    int32
	ProjectID   int32
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, insertPost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.IsPublished,
		arg.LabelID,
		arg.AuthorID,
		arg.ProjectID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
	)
	return i, err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO projects (name, description, accent_color, logo_url, app_key, user_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type InsertProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	AppKey      string
	UserID      uuid.UUID
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, insertProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.AppKey,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const insertRoadmapPost = `-- name: InsertRoadmapPost :one
INSERT INTO roadmap_posts (title, body, due_date, is_private, author_id, is_idea, viewer_id, board_id, status_id, project_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, viewer_id, is_idea, is_pinned, is_locked
`

type InsertRoadmapPostParams struct {
	Title     string
	Body      string
	DueDate   sql.NullTime
	IsPrivate bool
	AuthorID  sql.NullInt32
	IsIdea    bool
	ViewerID  sql.NullInt32
	BoardID   sql.NullInt32
	StatusID  sql.NullInt32
	ProjectID int32
}

func (q *Queries) InsertRoadmapPost(ctx context.Context, arg InsertRoadmapPostParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPost,
		arg.Title,
		arg.Body,
		arg.DueDate,
		arg.IsPrivate,
		arg.AuthorID,
		arg.IsIdea,
		arg.ViewerID,
		arg.BoardID,
		arg.StatusID,
		arg.ProjectID,
	)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.ViewerID,
		&i.IsIdea,
		&i.IsPinned,
		&i.IsLocked,
	)
	return i, err
}

const insertRoadmapPostActivity = `-- name: InsertRoadmapPostActivity :one
insert into roadmap_post_activity (from_status_id, to_status_id, roadmap_post_id, author_id) VALUES ($1, $2, $3, $4) RETURNING id, from_status_id, to_status_id, roadmap_post_id, author_id, created_on
`

type InsertRoadmapPostActivityParams struct {
	FromStatusID  sql.NullInt32
	ToStatusID    sql.NullInt32
	RoadmapPostID int32
	AuthorID      int32
}

func (q *Queries) InsertRoadmapPostActivity(ctx context.Context, arg InsertRoadmapPostActivityParams) (RoadmapPostActivity, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPostActivity,
		arg.FromStatusID,
		arg.ToStatusID,
		arg.RoadmapPostID,
		arg.AuthorID,
	)
	var i RoadmapPostActivity
	err := row.Scan(
		&i.ID,
		&i.FromStatusID,
		&i.ToStatusID,
		&i.RoadmapPostID,
		&i.AuthorID,
		&i.CreatedOn,
	)
	return i, err
}

const insertRoadmapPostComment = `-- name: InsertRoadmapPostComment :one
insert into roadmap_post_comments (content, in_reply_to_id, roadmap_post_id, author_id, viewer_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, content, is_pinned, is_deleted, in_reply_to_id, roadmap_post_id, author_id, viewer_id, created_on
`

type InsertRoadmapPostCommentParams struct {
	Content       string
	InReplyToID   sql.NullInt32
	RoadmapPostID int32
	AuthorID      sql.NullInt32
	ViewerID      sql.NullInt32
}

func (q *Queries) InsertRoadmapPostComment(ctx context.Context, arg InsertRoadmapPostCommentParams) (RoadmapPostComment, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPostComment,
		arg.Content,
		arg.InReplyToID,
		arg.RoadmapPostID,
		arg.AuthorID,
		arg.ViewerID,
	)
	var i RoadmapPostComment
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.IsPinned,
		&i.IsDeleted,
		&i.InReplyToID,
		&i.RoadmapPostID,
		&i.AuthorID,
		&i.ViewerID,
		&i.CreatedOn,
	)
	return i, err
}

const insertRoadmapPostReaction = `-- name: InsertRoadmapPostReaction :one
insert into roadmap_post_reactions (emoji, comment_id, roadmap_post_id, author_id, viewer_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, emoji, comment_id, roadmap_post_id, author_id, viewer_id, created_on
`

type InsertRoadmapPostReactionParams struct {
	Emoji         string
	CommentID     sql.NullInt32
	RoadmapPostID int32
	AuthorID      sql.NullInt32
	ViewerID      sql.NullInt32
}

func (q *Queries) InsertRoadmapPostReaction(ctx context.Context, arg InsertRoadmapPostReactionParams) (RoadmapPostReaction, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPostReaction,
		arg.Emoji,
		arg.CommentID,
		arg.RoadmapPostID,
		arg.AuthorID,
		arg.ViewerID,
	)
	var i RoadmapPostReaction
	err := row.Scan(
		&i.ID,
		&i.Emoji,
		&i.CommentID,
		&i.RoadmapPostID,
		&i.AuthorID,
		&i.ViewerID,
		&i.CreatedOn,
	)
	return i, err
}

const insertRoadmapPostVote = `-- name: InsertRoadmapPostVote :one
insert into roadmap_post_votes (roadmap_post_id, author_id, viewer_id) 
  select $1, $2, $3 from roadmap_posts p where p.id = $1 and p.project_id = $4
RETURNING id, roadmap_post_id, author_id, viewer_id, created_on
`

type InsertRoadmapPostVoteParams struct {
	RoadmapPostID int32
	AuthorID      sql.NullInt32
	ViewerID      sql.NullInt32
	ProjectID     int32
}

func (q *Queries) InsertRoadmapPostVote(ctx context.Context, arg InsertRoadmapPostVoteParams) (RoadmapPostVote, error) {
	row := q.db.QueryRowContext(ctx, insertRoadmapPostVote,
		arg.RoadmapPostID,
		arg.AuthorID,
		arg.ViewerID,
		arg.ProjectID,
	)
	var i RoadmapPostVote
	err := row.Scan(
		&i.ID,
		&i.RoadmapPostID,
		&i.AuthorID,
		&i.ViewerID,
		&i.CreatedOn,
	)
	return i, err
}

const insertStatus = `-- name: InsertStatus :one
INSERT INTO roadmap_statuses (status, description, color, project_id, created_on, sort_order) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, $5) RETURNING id, status, color, description, created_on, project_id, is_private, sort_order
`

type InsertStatusParams struct {
	Status      string
	Description string
	Color       string
	ProjectID   int32
	SortOrder   int32
}

func (q *Queries) InsertStatus(ctx context.Context, arg InsertStatusParams) (RoadmapStatus, error) {
	row := q.db.QueryRowContext(ctx, insertStatus,
		arg.Status,
		arg.Description,
		arg.Color,
		arg.ProjectID,
		arg.SortOrder,
	)
	var i RoadmapStatus
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Color,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
		&i.IsPrivate,
		&i.SortOrder,
	)
	return i, err
}

const insertViewer = `-- name: InsertViewer :one
INSERT INTO viewers (user_uuid, ip_addr, user_agent, locale, user_data, user_id, user_name, user_email, user_role, project_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, user_uuid, ip_addr, user_agent, locale, user_data, user_id, user_name, user_email, user_role, project_id, created_on
`

type InsertViewerParams struct {
	UserUuid  uuid.UUID
	IpAddr    string
	UserAgent string
	Locale    string
	UserData  pqtype.NullRawMessage
	UserID    sql.NullString
	UserName  sql.NullString
	UserEmail sql.NullString
	UserRole  sql.NullString
	ProjectID int32
}

// VIEWER --
func (q *Queries) InsertViewer(ctx context.Context, arg InsertViewerParams) (Viewer, error) {
	row := q.db.QueryRowContext(ctx, insertViewer,
		arg.UserUuid,
		arg.IpAddr,
		arg.UserAgent,
		arg.Locale,
		arg.UserData,
		arg.UserID,
		arg.UserName,
		arg.UserEmail,
		arg.UserRole,
		arg.ProjectID,
	)
	var i Viewer
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.IpAddr,
		&i.UserAgent,
		&i.Locale,
		&i.UserData,
		&i.UserID,
		&i.UserName,
		&i.UserEmail,
		&i.UserRole,
		&i.ProjectID,
		&i.CreatedOn,
	)
	return i, err
}

const toggleLockRoadmapPost = `-- name: ToggleLockRoadmapPost :one
update roadmap_posts set is_locked = !is_locked where id = $1 RETURNING id
`

func (q *Queries) ToggleLockRoadmapPost(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, toggleLockRoadmapPost, id)
	err := row.Scan(&id)
	return id, err
}

const togglePinRoadmapPostComment = `-- name: TogglePinRoadmapPostComment :one
update roadmap_post_comments set is_pinned = !is_pinned where id = $1 RETURNING id
`

func (q *Queries) TogglePinRoadmapPostComment(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, togglePinRoadmapPostComment, id)
	err := row.Scan(&id)
	return id, err
}

const unsetLabels = `-- name: UnsetLabels :many
UPDATE posts SET label_id = NULL WHERE id = $1 AND project_id = $2 RETURNING id
`

type UnsetLabelsParams struct {
	ID        int32
	ProjectID int32
}

func (q *Queries) UnsetLabels(ctx context.Context, arg UnsetLabelsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, unsetLabels, arg.ID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAuthor = `-- name: UpdateAuthor :one
UPDATE authors SET first_name = $1, last_name = $2, picture_url = $3 WHERE user_id = $4 and project_id = $5 RETURNING id, first_name, last_name, picture_url, user_id, project_id, created_on, updated_on
`

type UpdateAuthorParams struct {
	FirstName  string
	LastName   string
	PictureUrl sql.NullString
	UserID     uuid.UUID
	ProjectID  int32
}

func (q *Queries) UpdateAuthor(ctx context.Context, arg UpdateAuthorParams) (Author, error) {
	row := q.db.QueryRowContext(ctx, updateAuthor,
		arg.FirstName,
		arg.LastName,
		arg.PictureUrl,
		arg.UserID,
		arg.ProjectID,
	)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.PictureUrl,
		&i.UserID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updateBoard = `-- name: UpdateBoard :one
UPDATE roadmap_boards SET name = $1, is_private = $2, description = $3 WHERE id = $4 AND project_id = $5 RETURNING id, name, is_private, description, created_on, project_id
`

type UpdateBoardParams struct {
	Name        string
	IsPrivate   bool
	Description string
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdateBoard(ctx context.Context, arg UpdateBoardParams) (RoadmapBoard, error) {
	row := q.db.QueryRowContext(ctx, updateBoard,
		arg.Name,
		arg.IsPrivate,
		arg.Description,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapBoard
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsPrivate,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
	)
	return i, err
}

const updateInteraction = `-- name: UpdateInteraction :one
UPDATE changelog_interactions SET content = $1 WHERE viewer_id = $2 AND post_id = $3 AND interaction_type_id = $4 RETURNING id, content, interaction_type_id, post_id, viewer_id, project_id, created_on
`

type UpdateInteractionParams struct {
	Content           sql.NullString
	ViewerID          int32
	PostID            int32
	InteractionTypeID int32
}

func (q *Queries) UpdateInteraction(ctx context.Context, arg UpdateInteractionParams) (ChangelogInteraction, error) {
	row := q.db.QueryRowContext(ctx, updateInteraction,
		arg.Content,
		arg.ViewerID,
		arg.PostID,
		arg.InteractionTypeID,
	)
	var i ChangelogInteraction
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.InteractionTypeID,
		&i.PostID,
		&i.ViewerID,
		&i.ProjectID,
		&i.CreatedOn,
	)
	return i, err
}

const updateLabel = `-- name: UpdateLabel :one
UPDATE labels SET label = $1, color = $2 WHERE id = $3 AND project_id = $4 RETURNING id, label, color, project_id, created_on, updated_on
`

type UpdateLabelParams struct {
	Label     string
	Color     string
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateLabel(ctx context.Context, arg UpdateLabelParams) (Label, error) {
	row := q.db.QueryRowContext(ctx, updateLabel,
		arg.Label,
		arg.Color,
		arg.ID,
		arg.ProjectID,
	)
	var i Label
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Color,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts SET title = $1, body = $2, published_on = $3, is_published = $4, label_id = $5, expires_on = $6, updated_on = CURRENT_TIMESTAMP WHERE id = $7 AND project_id = $8 RETURNING id, title, body, published_on, author_id, project_id, created_on, updated_on, label_id, is_published, expires_on
`

type UpdatePostParams struct {
	Title       string
	Body        string
	PublishedOn time.Time
	IsPublished sql.NullBool
	LabelID     sql.NullInt32
	ExpiresOn   sql.NullTime
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Body,
		arg.PublishedOn,
		arg.IsPublished,
		arg.LabelID,
		arg.ExpiresOn,
		arg.ID,
		arg.ProjectID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.PublishedOn,
		&i.AuthorID,
		&i.ProjectID,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.LabelID,
		&i.IsPublished,
		&i.ExpiresOn,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET name = $1, description = $2, accent_color = $3, logo_url = $4, updated_on = CURRENT_TIMESTAMP WHERE id = $5 AND user_id = $6 RETURNING id, name, description, accent_color, logo_url, app_key, user_id, created_on, updated_on
`

type UpdateProjectParams struct {
	Name        string
	Description string
	AccentColor string
	LogoUrl     sql.NullString
	ID          int32
	UserID      uuid.UUID
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.AccentColor,
		arg.LogoUrl,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccentColor,
		&i.LogoUrl,
		&i.AppKey,
		&i.UserID,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const updateRoadmapPost = `-- name: UpdateRoadmapPost :one
UPDATE roadmap_posts SET title = $1, body = $2, due_date = $3, is_private = $4, board_id = $5, status_id = $6 WHERE id = $7 AND project_id = $8 RETURNING id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, viewer_id, is_idea, is_pinned, is_locked
`

type UpdateRoadmapPostParams struct {
	Title     string
	Body      string
	DueDate   sql.NullTime
	IsPrivate bool
	BoardID   sql.NullInt32
	StatusID  sql.NullInt32
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateRoadmapPost(ctx context.Context, arg UpdateRoadmapPostParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, updateRoadmapPost,
		arg.Title,
		arg.Body,
		arg.DueDate,
		arg.IsPrivate,
		arg.BoardID,
		arg.StatusID,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.ViewerID,
		&i.IsIdea,
		&i.IsPinned,
		&i.IsLocked,
	)
	return i, err
}

const updateRoadmapPostStatus = `-- name: UpdateRoadmapPostStatus :one
UPDATE roadmap_posts SET status_id = $1, board_id = $2 WHERE id = $3 AND project_id = $4 RETURNING id, title, body, due_date, board_id, project_id, status_id, created_on, is_private, author_id, viewer_id, is_idea, is_pinned, is_locked
`

type UpdateRoadmapPostStatusParams struct {
	StatusID  sql.NullInt32
	BoardID   sql.NullInt32
	ID        int32
	ProjectID int32
}

func (q *Queries) UpdateRoadmapPostStatus(ctx context.Context, arg UpdateRoadmapPostStatusParams) (RoadmapPost, error) {
	row := q.db.QueryRowContext(ctx, updateRoadmapPostStatus,
		arg.StatusID,
		arg.BoardID,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapPost
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.DueDate,
		&i.BoardID,
		&i.ProjectID,
		&i.StatusID,
		&i.CreatedOn,
		&i.IsPrivate,
		&i.AuthorID,
		&i.ViewerID,
		&i.IsIdea,
		&i.IsPinned,
		&i.IsLocked,
	)
	return i, err
}

const updateStatus = `-- name: UpdateStatus :one
UPDATE roadmap_statuses SET status = $1, description = $2, color = $3 WHERE id = $4 AND project_id = $5 RETURNING id, status, color, description, created_on, project_id, is_private, sort_order
`

type UpdateStatusParams struct {
	Status      string
	Description string
	Color       string
	ID          int32
	ProjectID   int32
}

func (q *Queries) UpdateStatus(ctx context.Context, arg UpdateStatusParams) (RoadmapStatus, error) {
	row := q.db.QueryRowContext(ctx, updateStatus,
		arg.Status,
		arg.Description,
		arg.Color,
		arg.ID,
		arg.ProjectID,
	)
	var i RoadmapStatus
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Color,
		&i.Description,
		&i.CreatedOn,
		&i.ProjectID,
		&i.IsPrivate,
		&i.SortOrder,
	)
	return i, err
}

const updateStatusOrder = `-- name: UpdateStatusOrder :one
UPDATE roadmap_statuses SET sort_order = $1 WHERE id = $2 AND project_id = $3 RETURNING id, status, sort_order, color
`

type UpdateStatusOrderParams struct {
	SortOrder int32
	ID        int32
	ProjectID int32
}

type UpdateStatusOrderRow struct {
	ID        int32
	Status    string
	SortOrder int32
	Color     string
}

func (q *Queries) UpdateStatusOrder(ctx context.Context, arg UpdateStatusOrderParams) (UpdateStatusOrderRow, error) {
	row := q.db.QueryRowContext(ctx, updateStatusOrder, arg.SortOrder, arg.ID, arg.ProjectID)
	var i UpdateStatusOrderRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.SortOrder,
		&i.Color,
	)
	return i, err
}

const updateViewer = `-- name: UpdateViewer :one
UPDATE viewers SET user_uuid = $1, ip_addr = $2, user_agent = $3, locale = $4, user_data = $5, user_id = $6, user_name = $7, user_email = $8, user_role = $9 WHERE id = $10 RETURNING id, user_uuid, ip_addr, user_agent, locale, user_data, user_id, user_name, user_email, user_role, project_id, created_on
`

type UpdateViewerParams struct {
	UserUuid  uuid.UUID
	IpAddr    string
	UserAgent string
	Locale    string
	UserData  pqtype.NullRawMessage
	UserID    sql.NullString
	UserName  sql.NullString
	UserEmail sql.NullString
	UserRole  sql.NullString
	ID        int32
}

func (q *Queries) UpdateViewer(ctx context.Context, arg UpdateViewerParams) (Viewer, error) {
	row := q.db.QueryRowContext(ctx, updateViewer,
		arg.UserUuid,
		arg.IpAddr,
		arg.UserAgent,
		arg.Locale,
		arg.UserData,
		arg.UserID,
		arg.UserName,
		arg.UserEmail,
		arg.UserRole,
		arg.ID,
	)
	var i Viewer
	err := row.Scan(
		&i.ID,
		&i.UserUuid,
		&i.IpAddr,
		&i.UserAgent,
		&i.Locale,
		&i.UserData,
		&i.UserID,
		&i.UserName,
		&i.UserEmail,
		&i.UserRole,
		&i.ProjectID,
		&i.CreatedOn,
	)
	return i, err
}

const userViewed = `-- name: UserViewed :one
SELECT COUNT(id) FROM changelog_interactions WHERE post_id = $1 and viewer_id = $2 AND interaction_type_id = 1
`

type UserViewedParams struct {
	PostID   int32
	ViewerID int32
}

func (q *Queries) UserViewed(ctx context.Context, arg UserViewedParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, userViewed, arg.PostID, arg.ViewerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}
